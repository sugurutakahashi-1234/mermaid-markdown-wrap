import { afterEach, beforeEach, describe, expect, test } from "bun:test";
import { mkdir, rm, writeFile } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { spawn } from "bun";
import type { ConfigOptions } from "../models/options.js";
import {
  CONFIG_FORMATS,
  generateConfigFileContent,
  generateConfigFileName,
} from "./config-file-generator.js";

describe("config-file-generator", () => {
  describe("generateConfigFileName", () => {
    test("generates correct TypeScript filename", () => {
      expect(generateConfigFileName("ts")).toBe(
        "mermaid-markdown-wrap.config.ts",
      );
    });

    test("generates correct JavaScript filename", () => {
      expect(generateConfigFileName("js")).toBe(
        "mermaid-markdown-wrap.config.js",
      );
    });

    test("generates correct CommonJS filename", () => {
      expect(generateConfigFileName("cjs")).toBe(
        "mermaid-markdown-wrap.config.cjs",
      );
    });

    test("generates correct ESM filename", () => {
      expect(generateConfigFileName("mjs")).toBe(
        "mermaid-markdown-wrap.config.mjs",
      );
    });

    test("generates correct JSON filename", () => {
      expect(generateConfigFileName("json")).toBe(
        ".mermaid-markdown-wraprc.json",
      );
    });

    test("generates correct YAML filename", () => {
      expect(generateConfigFileName("yaml")).toBe(
        ".mermaid-markdown-wraprc.yaml",
      );
    });
  });

  describe("generateConfigFileContent", () => {
    const sampleConfig: ConfigOptions = {
      outDir: "./output",
      header: "# Mermaid Diagrams",
      footer: "Generated by mermaid-markdown-wrap",
      removeSource: false,
      hideCommand: true,
      logFormat: "text",
      quiet: false,
    };

    test("generates correct TypeScript content", () => {
      const content = generateConfigFileContent(sampleConfig, "ts");
      expect(content).toContain(
        "import { defineConfig } from 'mermaid-markdown-wrap/config'",
      );
      expect(content).toContain("export default defineConfig(");
      expect(content).toContain('"outDir": "./output"');
      expect(content).toContain('"header": "# Mermaid Diagrams"');
      expect(content).toContain(
        '"footer": "Generated by mermaid-markdown-wrap"',
      );
      expect(content).toContain('"removeSource": false');
      expect(content).toContain('"hideCommand": true');
    });

    test("generates correct JavaScript content", () => {
      const content = generateConfigFileContent(sampleConfig, "js");
      expect(content).toContain(
        "/** @type {import('mermaid-markdown-wrap/config').ConfigOptions} */",
      );
      expect(content).toContain("module.exports =");
      expect(content).toContain('"outDir": "./output"');
    });

    test("generates correct CommonJS content", () => {
      const content = generateConfigFileContent(sampleConfig, "cjs");
      expect(content).toContain(
        "/** @type {import('mermaid-markdown-wrap/config').ConfigOptions} */",
      );
      expect(content).toContain("module.exports =");
      expect(content).toContain('"outDir": "./output"');
    });

    test("generates correct ESM content", () => {
      const content = generateConfigFileContent(sampleConfig, "mjs");
      expect(content).toContain(
        "/** @type {import('mermaid-markdown-wrap/config').ConfigOptions} */",
      );
      expect(content).toContain("export default");
      expect(content).toContain('"outDir": "./output"');
    });

    test("generates correct JSON content", () => {
      const content = generateConfigFileContent(sampleConfig, "json");
      const parsed = JSON.parse(content);
      expect(parsed).toEqual(sampleConfig);
    });

    test("generates correct YAML content", () => {
      const content = generateConfigFileContent(sampleConfig, "yaml");
      expect(content).toContain("outDir: ./output");
      expect(content).toContain('header: "# Mermaid Diagrams"');
      expect(content).toContain("footer: Generated by mermaid-markdown-wrap");
      expect(content).toContain("removeSource: false");
      expect(content).toContain("hideCommand: true");
    });
  });

  describe("config-validate integration", () => {
    let testDir: string;
    const cliPath = join(import.meta.dir, "../../presentation/cli.ts");

    beforeEach(async () => {
      // Create unique temp directory for each test
      testDir = join(
        tmpdir(),
        `mermaid-wrap-config-test-${Date.now()}-${Math.random().toString(36).slice(2)}`,
      );
      await mkdir(testDir, { recursive: true });
    });

    afterEach(async () => {
      // Clean up test directory
      try {
        await rm(testDir, { recursive: true, force: true });
      } catch {
        // Ignore cleanup errors
      }
    });

    const testConfig: ConfigOptions = {
      outDir: "./test-output",
      header: "# Test Header",
      footer: "Test Footer",
      removeSource: true,
      hideCommand: false,
      logFormat: "json",
      quiet: true,
    };

    // Test each config format
    CONFIG_FORMATS.forEach(({ format }) => {
      test(`validates ${format} config file`, async () => {
        // Generate config file
        const fileName = generateConfigFileName(format);
        const content = generateConfigFileContent(testConfig, format);
        const configPath = join(testDir, fileName);

        await writeFile(configPath, content);

        // Run config-validate command
        const proc = spawn(["bun", cliPath, "config-validate", configPath], {
          cwd: testDir,
          stdout: "pipe",
          stderr: "pipe",
        });

        const output = await new Response(proc.stdout).text();
        const error = await new Response(proc.stderr).text();
        await proc.exited;

        // Verify validation passed
        expect(proc.exitCode).toBe(0);
        expect(output).toContain("✅ Config looks good!");
        expect(error).toBe("");
      });
    });

    test("validates config with partial options", async () => {
      const partialConfig: Partial<ConfigOptions> = {
        outDir: "./partial-output",
        header: "Partial Header",
      };

      const configPath = join(testDir, ".mermaid-markdown-wraprc.json");
      await writeFile(configPath, JSON.stringify(partialConfig, null, 2));

      const proc = spawn(["bun", cliPath, "config-validate", configPath], {
        cwd: testDir,
        stdout: "pipe",
        stderr: "pipe",
      });

      const output = await new Response(proc.stdout).text();
      await proc.exited;

      expect(proc.exitCode).toBe(0);
      expect(output).toContain("✅ Config looks good!");
    });

    test("detects invalid config format", async () => {
      const invalidConfig = {
        outDir: 123, // Should be string
        header: true, // Should be string
        removeSource: "yes", // Should be boolean
      };

      const configPath = join(testDir, ".mermaid-markdown-wraprc.json");
      await writeFile(configPath, JSON.stringify(invalidConfig, null, 2));

      const proc = spawn(["bun", cliPath, "config-validate", configPath], {
        cwd: testDir,
        stdout: "pipe",
        stderr: "pipe",
      });

      const output = await new Response(proc.stdout).text();
      const error = await new Response(proc.stderr).text();
      await proc.exited;

      expect(proc.exitCode).toBe(1);
      expect(output + error).toContain("❌ Invalid config:");
    });

    test("handles non-existent config file", async () => {
      const proc = spawn(
        ["bun", cliPath, "config-validate", "non-existent.json"],
        {
          cwd: testDir,
          stdout: "pipe",
          stderr: "pipe",
        },
      );

      await new Response(proc.stdout).text();
      const error = await new Response(proc.stderr).text();
      await proc.exited;

      expect(proc.exitCode).toBe(1);
      expect(error).toContain("❌ Invalid config:");
    });
  });
});
