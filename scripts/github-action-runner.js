#!/usr/bin/env node

const fs = require("node:fs");
const path = require("node:path");
const { execSync } = require("node:child_process");

/**
 * GitHub Actions runner script
 * Handles both CLI execution and PR comment posting in a unified way
 */
async function runGitHubAction() {
  const mode = process.env.PR_COMMENT_MODE || "off";
  const shouldOutputJson = mode !== "off";

  try {
    // Build CLI command
    const args = process.argv.slice(2);
    if (shouldOutputJson) {
      args.push("--log-format", "json");
    }

    // Execute mermaid-markdown-wrap
    console.log("Converting files...");
    const command = `npx --yes mermaid-markdown-wrap ${args.map((arg) => `"${arg}"`).join(" ")}`;

    let output;
    let exitCode = 0;

    try {
      output = execSync(command, { encoding: "utf-8", stdio: "pipe" });
    } catch (error) {
      // Command failed but we still want to process the output
      output = error.stdout || "";
      exitCode = error.status || 1;
    }

    if (shouldOutputJson && output) {
      // Parse JSON output
      let results;
      try {
        results = JSON.parse(output);
      } catch (e) {
        console.error("Failed to parse JSON output:", e.message);
        console.log(output); // Fallback to raw output
        process.exit(exitCode);
      }

      // Display human-readable output
      console.log(
        `\nProcessing ${results.summary.totalMermaidFiles} file(s)...`,
      );

      for (const conversion of results.conversions) {
        if (conversion.converted) {
          console.log(`âœ“ ${conversion.mermaidFile}`);
        } else {
          console.error(
            `âœ— ${conversion.mermaidFile}: ${conversion.failureReason || "Unknown error"}`,
          );
        }
      }

      console.log(
        `\nDone! Successful: ${results.summary.successfulConversions}, Failed: ${results.summary.failedConversions}`,
      );

      // Save results for PR comment posting
      if (mode !== "off" && process.env.GITHUB_EVENT_NAME === "pull_request") {
        process.env.CONVERSION_RESULTS = JSON.stringify(results);
        await postPRComments(results, mode);
      }

      // Exit with appropriate code
      if (results.summary.failedConversions > 0) {
        process.exit(1);
      }
    } else {
      // Non-JSON output, just display as-is
      console.log(output);
      process.exit(exitCode);
    }
  } catch (error) {
    console.error("Error:", error.message);
    process.exit(1);
  }
}

/**
 * Post PR comments for generated markdown files
 */
async function postPRComments(conversionResults, mode) {
  const github = require("@actions/github");

  try {
    const token = process.env.GITHUB_TOKEN;
    const context = github.context;

    if (!token) {
      console.warn("GITHUB_TOKEN not found, skipping PR comments");
      return;
    }

    if (!context.payload.pull_request) {
      console.log("Not a pull request, skipping comment posting");
      return;
    }

    const octokit = github.getOctokit(token);
    const pr = context.payload.pull_request;

    // Get list of markdown files to post
    let mdFiles = [];
    const successfulFiles = conversionResults.conversions.filter(
      (f) => f.converted,
    );

    if (mode === "changed") {
      // Get only changed source files from git
      let changedFiles = [];
      try {
        changedFiles = execSync("git diff --name-only HEAD~1 HEAD", {
          encoding: "utf-8",
        })
          .trim()
          .split("\n")
          .filter((f) => f.endsWith(".mmd") || f.endsWith(".mermaid"));
      } catch (e) {
        console.warn("Failed to get changed files:", e.message);
        // Fall back to all files
        mdFiles = successfulFiles.map((file) => file.markdownFile);
      }

      if (changedFiles.length > 0) {
        // Filter to only include changed files that were successfully converted
        mdFiles = successfulFiles
          .filter((file) => changedFiles.includes(file.mermaidFile))
          .map((file) => file.markdownFile);
      }
    } else {
      // Get all files generated in this run
      mdFiles = successfulFiles.map((file) => file.markdownFile);
    }

    if (mdFiles.length === 0) {
      console.log("No markdown files found to post as comments");
      return;
    }

    console.log(`\nPosting ${mdFiles.length} file(s) as PR comments...`);

    // Post each file as a separate comment
    for (const mdFile of mdFiles) {
      try {
        const content = fs.readFileSync(mdFile, "utf-8");
        const filename = path.relative(process.cwd(), mdFile);

        // Create comment body with collapsible section
        const body = `## ðŸ“„ Generated Markdown: \`${filename}\`

<details>
<summary>Click to expand</summary>

${content}

</details>

---
*Generated by [mermaid-markdown-wrap](https://github.com/sugurutakahashi12345/mermaid-markdown-wrap)*`;

        await octokit.rest.issues.createComment({
          owner: context.repo.owner,
          repo: context.repo.repo,
          issue_number: pr.number,
          body: body,
        });

        console.log(`âœ“ Posted comment for: ${filename}`);
      } catch (e) {
        console.error(`âœ— Failed to post comment for ${mdFile}: ${e.message}`);
      }
    }

    console.log("\nSuccessfully completed PR comment posting");
  } catch (error) {
    // Don't fail the whole action if PR comments fail
    console.error(`Warning: Failed to post PR comments: ${error.message}`);
  }
}

// Run if called directly
if (require.main === module) {
  runGitHubAction();
}

module.exports = { runGitHubAction, postPRComments };
